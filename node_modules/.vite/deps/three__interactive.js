import {
  Raycaster,
  Vector2
} from "./chunk-YIGHD3MU.js";
import {
  __publicField
} from "./chunk-DSTXS4JB.js";

// node_modules/three.interactive/build/three.interactive.js
var c = class {
  constructor(e, s) {
    __publicField(this, "target");
    __publicField(this, "name");
    __publicField(this, "intersected");
    __publicField(this, "wasIntersected", false);
    __publicField(this, "distance");
    this.target = e, this.name = s, this.intersected = false, this.distance = 0;
  }
};
var i = class {
  constructor(e, s = null) {
    __publicField(this, "type");
    __publicField(this, "cancelBubble");
    __publicField(this, "originalEvent");
    __publicField(this, "coords", new Vector2(0, 0));
    __publicField(this, "distance", 0);
    __publicField(this, "intersected", false);
    this.cancelBubble = false, this.type = e, this.originalEvent = s;
  }
  stopPropagation() {
    this.cancelBubble = true;
  }
};
var u = class {
  constructor(e, s, t, n) {
    __publicField(this, "renderer");
    __publicField(this, "camera");
    __publicField(this, "domElement");
    __publicField(this, "bindEventsOnBodyElement");
    __publicField(this, "mouse");
    __publicField(this, "supportsPointerEvents");
    __publicField(this, "interactiveObjects");
    __publicField(this, "closestObject");
    __publicField(this, "raycaster");
    __publicField(this, "treatTouchEventsAsMouseEvents");
    __publicField(this, "dispose", () => {
      this.domElement.removeEventListener("click", this.onMouseClick), this.supportsPointerEvents ? (this.domElement.ownerDocument.removeEventListener("pointermove", this.onDocumentMouseMove), this.domElement.removeEventListener("pointerdown", this.onMouseDown), this.domElement.removeEventListener("pointerup", this.onMouseUp)) : (this.domElement.ownerDocument.removeEventListener("mousemove", this.onDocumentMouseMove), this.domElement.removeEventListener("mousedown", this.onMouseDown), this.domElement.removeEventListener("mouseup", this.onMouseUp), this.domElement.removeEventListener("touchstart", this.onTouchStart), this.domElement.removeEventListener("touchmove", this.onTouchMove), this.domElement.removeEventListener("touchend", this.onTouchEnd));
    });
    __publicField(this, "add", (e, s = []) => {
      if (e)
        if (s.length > 0)
          s.forEach((t) => {
            let n = e.getObjectByName(t);
            if (n) {
              let o = new c(n, t);
              this.interactiveObjects.push(o);
            }
          });
        else {
          let t = new c(e, e.name);
          this.interactiveObjects.push(t);
        }
    });
    __publicField(this, "remove", (e, s = []) => {
      if (!e)
        return;
      let t = new Set(s.length > 0 ? s : [e.name]);
      this.interactiveObjects = this.interactiveObjects.filter((n) => !t.has(n.name));
    });
    __publicField(this, "update", () => {
      var _a;
      this.raycaster.setFromCamera(this.mouse, this.camera), this.interactiveObjects.forEach((n) => {
        n.target && this.checkIntersection(n);
      }), this.interactiveObjects.sort(function(n, o) {
        return n.distance - o.distance;
      });
      let e = (_a = this.interactiveObjects.find((n) => n.intersected)) != null ? _a : null;
      if (e != this.closestObject) {
        if (this.closestObject) {
          let n = new i("mouseout");
          this.dispatch(this.closestObject, n);
        }
        if (e) {
          let n = new i("mouseover");
          this.dispatch(e, n);
        }
        this.closestObject = e;
      }
      let s;
      this.interactiveObjects.forEach((n) => {
        !n.intersected && n.wasIntersected && (s || (s = new i("mouseleave")), this.dispatch(n, s));
      });
      let t;
      this.interactiveObjects.forEach((n) => {
        n.intersected && !n.wasIntersected && (t || (t = new i("mouseenter")), this.dispatch(n, t));
      });
    });
    __publicField(this, "checkIntersection", (e) => {
      let s = this.raycaster.intersectObjects([e.target], true);
      if (e.wasIntersected = e.intersected, s.length > 0) {
        let t = s[0].distance;
        s.forEach((n) => {
          n.distance < t && (t = n.distance);
        }), e.intersected = true, e.distance = t;
      } else
        e.intersected = false;
    });
    __publicField(this, "onDocumentMouseMove", (e) => {
      this.mapPositionToPoint(this.mouse, e.clientX, e.clientY);
      let s = new i("mousemove", e);
      this.interactiveObjects.forEach((t) => {
        this.dispatch(t, s);
      });
    });
    __publicField(this, "onTouchMove", (e) => {
      this.mapPositionToPoint(this.mouse, e.touches[0].clientX, e.touches[0].clientY);
      let s = new i(this.treatTouchEventsAsMouseEvents ? "mousemove" : "touchmove", e);
      this.interactiveObjects.forEach((t) => {
        this.dispatch(t, s);
      });
    });
    __publicField(this, "onMouseClick", (e) => {
      this.update();
      let s = new i("click", e);
      this.interactiveObjects.forEach((t) => {
        t.intersected && this.dispatch(t, s);
      });
    });
    __publicField(this, "onMouseDown", (e) => {
      this.mapPositionToPoint(this.mouse, e.clientX, e.clientY), this.update();
      let s = new i("mousedown", e);
      this.interactiveObjects.forEach((t) => {
        t.intersected && this.dispatch(t, s);
      });
    });
    __publicField(this, "onTouchStart", (e) => {
      this.mapPositionToPoint(this.mouse, e.touches[0].clientX, e.touches[0].clientY), this.update();
      let s = new i(this.treatTouchEventsAsMouseEvents ? "mousedown" : "touchstart", e);
      this.interactiveObjects.forEach((t) => {
        t.intersected && this.dispatch(t, s);
      });
    });
    __publicField(this, "onMouseUp", (e) => {
      let s = new i("mouseup", e);
      this.interactiveObjects.forEach((t) => {
        this.dispatch(t, s);
      });
    });
    __publicField(this, "onTouchEnd", (e) => {
      this.mapPositionToPoint(this.mouse, e.touches[0].clientX, e.touches[0].clientY), this.update();
      let s = new i(this.treatTouchEventsAsMouseEvents ? "mouseup" : "touchend", e);
      this.interactiveObjects.forEach((t) => {
        this.dispatch(t, s);
      });
    });
    __publicField(this, "dispatch", (e, s) => {
      e.target && !s.cancelBubble && (s.coords = this.mouse, s.distance = e.distance, s.intersected = e.intersected, e.target.dispatchEvent(s));
    });
    __publicField(this, "mapPositionToPoint", (e, s, t) => {
      let n = this.renderer.domElement.getBoundingClientRect();
      e.x = (s - n.left) / n.width * 2 - 1, e.y = -((t - n.top) / n.height) * 2 + 1;
    });
    this.renderer = e, this.camera = s, this.domElement = t, this.bindEventsOnBodyElement = true, typeof n < "u" && n && (this.bindEventsOnBodyElement = false), this.mouse = new Vector2(-1, 1), this.supportsPointerEvents = !!window.PointerEvent, this.interactiveObjects = [], this.closestObject = null, this.raycaster = new Raycaster(), t.addEventListener("click", this.onMouseClick), this.supportsPointerEvents ? (this.bindEventsOnBodyElement ? t.ownerDocument.addEventListener("pointermove", this.onDocumentMouseMove) : t.addEventListener("pointermove", this.onDocumentMouseMove), t.addEventListener("pointerdown", this.onMouseDown), t.addEventListener("pointerup", this.onMouseUp)) : (this.bindEventsOnBodyElement ? t.ownerDocument.addEventListener("mousemove", this.onDocumentMouseMove) : t.addEventListener("mousemove", this.onDocumentMouseMove), t.addEventListener("mousedown", this.onMouseDown), t.addEventListener("mouseup", this.onMouseUp), t.addEventListener("touchstart", this.onTouchStart, { passive: true }), t.addEventListener("touchmove", this.onTouchMove, { passive: true }), t.addEventListener("touchend", this.onTouchEnd, { passive: true })), this.treatTouchEventsAsMouseEvents = true;
  }
};
export {
  u as InteractionManager,
  i as InteractiveEvent,
  c as InteractiveObject
};
//# sourceMappingURL=three__interactive.js.map
